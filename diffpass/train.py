# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/train.ipynb.

# %% auto 0
__all__ = ['global_argmax_from_group_argmaxes', 'apply_hard_permutation_batch_to_similarity', 'DiffPASSResults',
           'InformationAndReciprocalBestHits']

# %% ../nbs/train.ipynb 2
# Stdlib imports
from collections.abc import Iterable, Sequence
from typing import Optional, Union, Any, Literal
from dataclasses import dataclass
from copy import deepcopy

# Progress bars
from tqdm import tqdm

# PyTorch
import torch
from torch.nn import Module

# DiffPASS imports
from .base import EnsembleMixin, DiffPASSMixin, scalar_or_1d_tensor
from diffpass.model import (
    GeneralizedPermutation,
    EnsembleMatrixApply,
    TwoBodyEntropyLoss,
    MILoss,
    HammingSimilarities,
    ReciprocalBestHits,
    Blosum62Similarities,
    InterGroupLoss,
    IntraGroupLoss,
)

# %% ../nbs/train.ipynb 3
def global_argmax_from_group_argmaxes(mats: Iterable[torch.Tensor]) -> torch.Tensor:
    global_argmax = []
    start_idx = 0
    for mats_this_group in mats:
        global_argmax.append(mats_this_group.argmax(-1) + start_idx)
        start_idx += mats_this_group.shape[-1]

    return torch.cat(global_argmax, dim=-1)


def apply_hard_permutation_batch_to_similarity(
    *, x: torch.Tensor, perms: list[torch.Tensor]
) -> torch.Tensor:
    """
    Conjugate a single similarity matrix by a batch of hard permutations.

    Args:
        perms: List of batches of permutation matrices of shape (..., D, D).
        x: Similarity matrix of shape (D, D).

    Returns:
        Batch of conjugated matrices of shape (..., D, D).
    """
    global_argmax = global_argmax_from_group_argmaxes(perms)
    x_permuted_rows = x[global_argmax]

    # Permuting columns is more involved
    index = global_argmax.view(*global_argmax.shape[:-1], 1, -1).expand(
        *global_argmax.shape, global_argmax.shape[-1]
    )
    # Example of gather with 4D tensor and dim=-1:
    # out[i][j][k][l] = input[i][j][k][index[i][j][k][l]]

    return torch.gather(x_permuted_rows, -1, index)


def _dcc(x: torch.Tensor) -> torch.Tensor:
    return x.detach().clone().cpu()

# %% ../nbs/train.ipynb 5
@dataclass
class DiffPASSResults:
    log_alphas: list[list[torch.Tensor]]
    # Perms
    soft_perms: list[list[torch.Tensor]]
    hard_perms: list[list[torch.Tensor]]
    # Losses
    hard_losses: dict[str, list[torch.Tensor]]
    soft_losses: dict[str, list[torch.Tensor]]
    # Losses with identity perm
    hard_losses_identity_perm: dict[str, Optional[float]]
    soft_losses_identity_perm: Optional[dict[str, Optional[float]]] = None

# %% ../nbs/train.ipynb 6
class InformationAndReciprocalBestHits(Module, EnsembleMixin, DiffPASSMixin):
    def __init__(
        self,
        group_sizes: Iterable[int],
        fixed_matchings: Optional[Sequence[Sequence[Sequence[int]]]] = None,
        loss_weights: Optional[dict[str, Union[float, torch.Tensor]]] = None,
        permutation_cfg: Optional[dict[str, Any]] = None,
        information_measure: Literal["MI", "TwoBodyEntropy"] = "TwoBodyEntropy",
        similarity_kind: Literal["Hamming", "Blosum62"] = "Hamming",
        similarities_cfg: Optional[dict[str, Any]] = None,
        reciprocal_best_hits_cfg: Optional[dict[str, Any]] = None,
        inter_group_loss_score_fn: Optional[callable] = None,
    ):
        super().__init__()
        self.group_sizes = tuple(s for s in group_sizes)
        self.fixed_matchings = fixed_matchings
        self.loss_weights = loss_weights
        self.permutation_cfg = permutation_cfg
        self.information_measure = information_measure
        self.similarity_kind = similarity_kind
        self.similarities_cfg = similarities_cfg
        self.reciprocal_best_hits_cfg = reciprocal_best_hits_cfg
        self.inter_group_loss_score_fn = inter_group_loss_score_fn

        ensemble_shape = []
        _dim_in_ensemble = -1

        if permutation_cfg is None:
            permutation_cfg = {}
        else:
            self.validate_permutation_cfg(permutation_cfg)
            permutation_cfg = deepcopy(permutation_cfg)
            _dim_in_ensemble = self._adjust_cfg_and_ensemble_shape(
                ensemble_shape=ensemble_shape,
                cfg=permutation_cfg,
                param_name="tau",
                prev_dim_in_ensemble=_dim_in_ensemble,
            )
        self.effective_permutation_cfg_ = permutation_cfg

        self.validate_information_measure(information_measure)
        self.loss_weights_keys = {self.information_measure, "ReciprocalBestHits"}

        self.validate_similarity_kind(similarity_kind)
        if similarities_cfg is None:
            similarities_cfg = {}
        else:
            self.validate_similarities_cfg(similarities_cfg)
            similarities_cfg = deepcopy(similarities_cfg)
        self.effective_similarities_cfg_ = similarities_cfg

        if reciprocal_best_hits_cfg is None:
            reciprocal_best_hits_cfg = {}
        else:
            self.validate_reciprocal_best_hits_cfg(reciprocal_best_hits_cfg)
            reciprocal_best_hits_cfg = deepcopy(reciprocal_best_hits_cfg)
            _dim_in_ensemble = self._adjust_cfg_and_ensemble_shape(
                ensemble_shape=ensemble_shape,
                cfg=reciprocal_best_hits_cfg,
                param_name="tau",
                prev_dim_in_ensemble=_dim_in_ensemble,
            )
        self.effective_reciprocal_best_hits_cfg_ = reciprocal_best_hits_cfg

        if loss_weights is not None:
            loss_weights = deepcopy(loss_weights)
            _dim_in_ensemble = self._adjust_loss_weights_and_ensemble_shape(
                loss_weights=loss_weights,
                ensemble_shape=ensemble_shape,
                prev_dim_in_ensemble=_dim_in_ensemble,
            )
        else:
            loss_weights = {
                self.information_measure: torch.tensor(0.5),
                "ReciprocalBestHits": torch.tensor(0.5),
            }

        ensemble_shape = tuple(ensemble_shape)

        self.permutation = GeneralizedPermutation(
            group_sizes=self.group_sizes,
            ensemble_shape=ensemble_shape,
            fixed_matchings=fixed_matchings,
            mode="soft",
            **permutation_cfg,
        )
        self.ensemble_matrix_apply = EnsembleMatrixApply(group_sizes=self.group_sizes)
        if self.information_measure == "TwoBodyEntropy":
            self.information_loss = TwoBodyEntropyLoss()
        elif self.information_measure == "MI":
            self.information_loss = MILoss()
        self.information_loss.register_buffer(
            "weight", loss_weights[self.information_measure]
        )

        if similarity_kind == "Blosum62":
            self.similarities = Blosum62Similarities(**similarities_cfg)
        elif similarity_kind == "Hamming":
            self.similarities = HammingSimilarities(**similarities_cfg)
        self.reciprocal_best_hits = ReciprocalBestHits(
            group_sizes=self.group_sizes,
            ensemble_shape=ensemble_shape,
            mode="soft",
            **reciprocal_best_hits_cfg,
        )
        self.reciprocal_best_hits.register_buffer(
            "weight", loss_weights["ReciprocalBestHits"]
        )
        self.inter_group_loss = InterGroupLoss(
            group_sizes=self.group_sizes, score_fn=self.inter_group_loss_score_fn
        )

    @property
    def effective_loss_weights_(self) -> dict[str, torch.Tensor]:
        return {
            self.information_measure: self.information_loss.weight,
            "ReciprocalBestHits": self.reciprocal_best_hits.weight,
        }

    @staticmethod
    def _adjust_cfg_and_ensemble_shape(
        *,
        ensemble_shape: list[int],
        cfg: dict[str, Any],
        param_name: str,
        prev_dim_in_ensemble: int = -1,
    ) -> int:
        new_dim_in_ensemble = prev_dim_in_ensemble
        if param_name in cfg:
            param = scalar_or_1d_tensor(param=cfg[param_name], param_name=param_name)
            cfg[param_name] = param
            if param.ndim == 1:
                ensemble_shape += list(param.shape)
                new_dim_in_ensemble += 1
                cfg[f"{param_name}_dim_in_ensemble"] = new_dim_in_ensemble

        return new_dim_in_ensemble

    def _adjust_loss_weights_and_ensemble_shape(
        self,
        *,
        loss_weights: Optional[dict[str, Any]] = None,
        ensemble_shape: list[int],
        prev_dim_in_ensemble: int = -1,
    ) -> int:
        new_dim_in_ensemble = prev_dim_in_ensemble
        if set(loss_weights) != self.loss_weights_keys:
            raise ValueError(
                "`loss_weights` must be a dictionary with key set equal to "
                f"{self.loss_weights_keys}."
            )

        loss_weight_entr = loss_weights[self.information_measure]
        loss_weight_entr = scalar_or_1d_tensor(
            param=loss_weight_entr,
            param_name=f"``loss_weights['{self.information_measure}']``",
        )
        loss_weight_rbh = loss_weights["ReciprocalBestHits"]
        loss_weight_rbh = scalar_or_1d_tensor(
            param=loss_weight_rbh, param_name="``loss_weights['ReciprocalBestHits']``"
        )

        if loss_weight_entr.ndim == 1 and loss_weight_rbh.ndim == 1:
            if loss_weight_entr.shape != loss_weight_rbh.shape:
                raise ValueError(
                    f"1D ``loss_weights['{self.information_measure}']`` and 1D "
                    "``loss_weights['ReciprocalBestHits']`` must have the same shape."
                )
            ensemble_shape += list(loss_weight_entr.shape)
            new_dim_in_ensemble += 1
        elif loss_weight_entr.ndim == 1 and loss_weight_rbh.ndim == 0:
            loss_weight_rbh = loss_weight_rbh.repeat(loss_weight_entr.shape[0])
            ensemble_shape += list(loss_weight_entr.shape)
            new_dim_in_ensemble += 1
        elif loss_weight_entr.ndim == 0 and loss_weight_rbh.ndim == 1:
            loss_weight_entr = loss_weight_entr.repeat(loss_weight_rbh.shape[0])
            ensemble_shape += list(loss_weight_rbh.shape)
            new_dim_in_ensemble += 1
        loss_weight_entr = self._reshape_ensemble_param(
            param=loss_weight_entr,
            ensemble_shape=ensemble_shape,
            dim_in_ensemble=new_dim_in_ensemble,
            n_dims_per_instance=0,
            param_name=f"``loss_weights['{self.information_measure}']``",
        )
        loss_weight_rbh = self._reshape_ensemble_param(
            param=loss_weight_rbh,
            ensemble_shape=ensemble_shape,
            dim_in_ensemble=new_dim_in_ensemble,
            n_dims_per_instance=0,
            param_name="``loss_weights['ReciprocalBestHits']``",
        )
        loss_weights[self.information_measure] = loss_weight_entr
        loss_weights["ReciprocalBestHits"] = loss_weight_rbh

        return new_dim_in_ensemble

    def _precompute_rbh(self, x: torch.Tensor, y: torch.Tensor) -> None:
        # Temporarily switch to hard RBH
        self.reciprocal_best_hits.hard_()
        similarities_x = self.similarities(x)
        self.register_buffer("_rbh_hard_x", self.reciprocal_best_hits(similarities_x))
        similarities_y = self.similarities(y)
        self.register_buffer("_rbh_hard_y", self.reciprocal_best_hits(similarities_y))

        # Revert to soft (default) RBH
        self.reciprocal_best_hits.soft_()
        self.register_buffer("_rbh_soft_x", self.reciprocal_best_hits(similarities_x))
        similarities_y = self.reciprocal_best_hits.prepare_fixed(similarities_y)
        self.register_buffer("_rbh_soft_y", self.reciprocal_best_hits(similarities_y))

    def forward(
        self,
        x: torch.Tensor,
        y: torch.Tensor,
        *,
        x_perm_hard: Optional[torch.Tensor] = None,
    ) -> dict[str, torch.Tensor]:
        mode = self.permutation.mode
        assert mode == self.reciprocal_best_hits.mode

        # Soft or hard permutations (list)
        perms = self.permutation()
        x_perm = self.ensemble_matrix_apply(x, mats=perms)

        # Two-body entropy portion of the loss
        loss_info = self.information_loss(x_perm, y)

        # Reciprocal best hits portion of the loss, with shortcut for hard permutations
        if mode == "soft":
            if x_perm_hard is not None:
                x_perm = (x_perm_hard - x_perm).detach() + x_perm
            similarities_x = self.similarities(x_perm)
            rbh_x = self.reciprocal_best_hits(similarities_x)
        else:
            rbh_x = apply_hard_permutation_batch_to_similarity(
                x=self._rbh_hard_x, perms=perms
            )
        # Ensure comparisons are only hard-hard or soft-soft
        loss_rbh = self.inter_group_loss(rbh_x, getattr(self, f"_rbh_{mode}_y"))

        return {
            "perms": perms,
            "x_perm": x_perm,
            "loss_info": loss_info,
            "loss_rbh": loss_rbh,
        }

    def soft_(self) -> None:
        self.permutation.soft_()
        self.reciprocal_best_hits.soft_()

    def hard_(self) -> None:
        self.permutation.hard_()
        self.reciprocal_best_hits.hard_()

    def _prepare_fit(self, x: torch.Tensor, y: torch.Tensor) -> DiffPASSResults:
        # Validate inputs
        self.validate_inputs(x, y)

        # Precompute matrices of reciprocal best hits
        self._precompute_rbh(x, y)

        # Initialize DiffPassResults object
        results = DiffPASSResults(
            log_alphas=[],
            soft_perms=[],
            hard_perms=[],
            soft_losses={self.information_measure: [], "ReciprocalBestHits": []},
            hard_losses={self.information_measure: [], "ReciprocalBestHits": []},
            hard_losses_identity_perm={
                self.information_measure: None,
                "ReciprocalBestHits": None,
            },
            soft_losses_identity_perm={
                self.information_measure: None,
                "ReciprocalBestHits": None,
            },
        )

        # Compute hard losses with identity permutation
        self.hard_()
        with torch.no_grad():
            results.hard_losses_identity_perm[
                self.information_measure
            ] = self.information_loss(x, y).item()
            results.hard_losses_identity_perm[
                "ReciprocalBestHits"
            ] = self.inter_group_loss(self._rbh_hard_x, self._rbh_hard_y).item()
            results.soft_losses_identity_perm[
                self.information_measure
            ] = results.hard_losses_identity_perm[self.information_measure]
            results.soft_losses_identity_perm["ReciprocalBestHits"] = _dcc(
                self.inter_group_loss(self._rbh_soft_x, self._rbh_soft_y)
            )

        return results

    def _fit(
        self,
        x: torch.Tensor,
        y: torch.Tensor,
        results: DiffPASSResults,
        *,
        epochs: int = 1,
        optimizer_name: Optional[str] = "SGD",
        optimizer_kwargs: Optional[dict[str, Any]] = None,
        mean_centering: bool = True,
        similarity_gradient_bypass: bool = False,
        show_pbar: bool = True,
        compute_final_soft: bool = True,
    ) -> DiffPASSResults:
        # Initialize optimizer
        optimizer_cls = getattr(torch.optim, optimizer_name)
        optimizer_kwargs = (
            {"lr": 1e-1} if optimizer_kwargs is None else deepcopy(optimizer_kwargs)
        )
        self.optimizer_ = optimizer_cls(self.parameters(), **optimizer_kwargs)

        # Progress bar
        pbar = range(epochs + 1)
        if show_pbar:
            pbar = tqdm(pbar)

        # ------------------------------------------------------------------------------------------
        ## Gradient descent
        # ------------------------------------------------------------------------------------------
        x_perm_hard = None
        with torch.set_grad_enabled(True):
            self.optimizer_.zero_grad()
            for i in pbar:
                # Hard pass
                self.hard_()
                with torch.no_grad():
                    epoch_results = self(x, y)
                    loss_info = epoch_results["loss_info"]
                    loss_rbh = epoch_results["loss_rbh"]
                    if similarity_gradient_bypass:
                        x_perm_hard = epoch_results["x_perm"]
                    perms = epoch_results["perms"]
                    results.log_alphas.append(
                        [_dcc(log_alpha) for log_alpha in self.permutation.log_alphas]
                    )
                    results.hard_perms.append(
                        [
                            _dcc(perms_this_group).argmax(-1).to(torch.int16)
                            for perms_this_group in perms
                        ]
                    )
                    results.hard_losses[self.information_measure].append(
                        _dcc(loss_info)
                    )
                    results.hard_losses["ReciprocalBestHits"].append(_dcc(loss_rbh))

                # Soft pass
                if i < epochs or compute_final_soft:
                    self.soft_()
                    epoch_results = self(x, y, x_perm_hard=x_perm_hard)
                    loss_info = epoch_results["loss_info"]
                    loss_rbh = epoch_results["loss_rbh"]
                    perms = epoch_results["perms"]
                    results.soft_perms.append(
                        [_dcc(perms_this_group) for perms_this_group in perms]
                    )
                    results.soft_losses[self.information_measure].append(
                        _dcc(loss_info)
                    )
                    results.soft_losses["ReciprocalBestHits"].append(_dcc(loss_rbh))

                    loss = (
                        self.information_loss.weight * loss_info
                        + self.reciprocal_best_hits.weight * loss_rbh
                    ).sum()
                    loss.backward()
                if i < epochs:
                    self.optimizer_.step()
                    self.optimizer_.zero_grad()
                    if mean_centering:
                        with torch.no_grad():
                            for log_alpha in self.permutation.log_alphas:
                                log_alpha[...] -= log_alpha.mean(
                                    dim=(-1, -2), keepdim=True
                                )

        return results

    def fit(
        self,
        x: torch.Tensor,
        y: torch.Tensor,
        *,
        epochs: int = 1,
        optimizer_name: Optional[str] = "SGD",
        optimizer_kwargs: Optional[dict[str, Any]] = None,
        mean_centering: bool = True,
        similarity_gradient_bypass: bool = False,
        show_pbar: bool = True,
        compute_final_soft: bool = True,
    ) -> DiffPASSResults:
        results = self._prepare_fit(x, y)
        results = self._fit(
            x,
            y,
            results,
            epochs=epochs,
            optimizer_name=optimizer_name,
            optimizer_kwargs=optimizer_kwargs,
            mean_centering=mean_centering,
            similarity_gradient_bypass=similarity_gradient_bypass,
            show_pbar=show_pbar,
            compute_final_soft=compute_final_soft,
        )

        return results
